#textdomain wesnoth-h2tt





#############################
# LISAR
#############################
#define ABILITY_EXACTING
    [dummy] # if you change this ID, also change the unit filter in the implementation
        id,name=exacting,_"exacting"
        description= _ "Li’sar has drilled her infantry to perfection. Though few in number, each of her soldiers possesses skills not usually seen on others of their type."
    [/dummy]
#enddef

#define MARCH_MOVEMENT
    # also used by Lisar
    forest,cave,frozen=1,1,2
    reef,shallow_water,swamp_water=2,2,2
    mountain=3
#     flat,sand,frozen,cave=1,1,2,1
#     forest,hills,mountains,fungus=1,2,3,2
#     reef,shallow_water,swamp_water=2,2,2
#     village,castle=1,1
#enddef
#define MARCH_DEFENSE
    # also used by Lisar
    mountains=60
#     flat,sand,frozen,cave=60,70,70,60
#     forest,hills,mountains,fungus=50,50,50,50
#     reef,shallow_water,swamp_water=70,80,80
#     village,castle=50,40
#enddef
#define GLOBAL__EXACTING_IMPLEMENTATION
    #------------------
    # EXPLAIN EXACTING
    #------------------
    [event]
        name=side 1 turn end
        {FILTER_CONDITION( {HAVE_UNIT id=Lisar} )}
        {FILTER_CONDITION( {VARIABLE_CONDITIONAL met_lisar not_equals yes} )}
        [message]
            speaker=Konrad
            message= _ "I studied Princess Li’sar back in the Aethenwood. Though her company is not large in number, each of them possesses skills not usually seen on others of their type."
        [/message]
        {VARIABLE met_lisar yes}
    [/event]
    
    #------------------
    # HEAVY INFANTRYMAN
    #------------------
    # fearless + march makes them great in caves (and HI also get 40% cave defense by default for some reason)
    [event]
        name,first_time_only=unit placed,no
        {FILTER type_adv_tree="Heavy Infantryman"}
        {FILTER_CONDITION( {HAVE_UNIT side,ability=$unit.side,exacting} )}
        
        # always fearless. Because why not? (and important for the Sceptre of Fire cave scenario)
        {STORE_UNIT_VAR id=$unit.id hitpoints     exacting_hitpoints}
        {STORE_UNIT_VAR id=$unit.id max_hitpoints exacting_max_hitpoints}
        [remove_trait] id,trait_id=$unit.id,quick       {BR}[/remove_trait] # don't remove loyal
        [remove_trait] id,trait_id=$unit.id,strong      {BR}[/remove_trait]
        [remove_trait] id,trait_id=$unit.id,intelligent {BR}[/remove_trait]
        [remove_trait] id,trait_id=$unit.id,resilient   {BR}[/remove_trait]
        [remove_trait] id,trait_id=$unit.id,fearless    {BR}[/remove_trait]
        {VARIABLE_OP traitname rand "1,2,3,4"} # always either strong or resilient. Intelligent isn't very useful for AI and quick+march makes them too fast
        [if] {VARIABLE_CONDITIONAL traitname equals 1} {THEN([modify_unit] {FILTER id=$unit.id} {TRAIT_FEARLESS}{TRAIT_STRONG}    [/modify_unit])} [/if]
        [if] {VARIABLE_CONDITIONAL traitname equals 2} {THEN([modify_unit] {FILTER id=$unit.id} {TRAIT_FEARLESS}{TRAIT_RESILIENT} [/modify_unit])} [/if]
        [if] {VARIABLE_CONDITIONAL traitname equals 3} {THEN([modify_unit] {FILTER id=$unit.id} {TRAIT_STRONG}   {TRAIT_FEARLESS} [/modify_unit])} [/if]
        [if] {VARIABLE_CONDITIONAL traitname equals 4} {THEN([modify_unit] {FILTER id=$unit.id} {TRAIT_RESILIENT}{TRAIT_FEARLESS} [/modify_unit])} [/if]
        [if] {VARIABLE_CONDITIONAL exacting_hitpoints equals $exacting_max_hitpoints} {THEN( {FULL_HEAL id=$unit.id} )} [/if]
        {CLEAR_VARIABLE exacting_hitpoints,exacting_max_hitpoints,traitname}
        
        # "march" ability
        {REMOVE_OBJECT exacting_object id=$unit.id}
        {GIVE_OBJECT_TO id=$unit.id (id=exacting_object
            {EFFECT new_ability ([abilities]
                [dummy]
                    id,name=march,_"march"
#                     description= _ "This unit has reduced movement cost and improved dodge on most terrains."
                    description= _ "This unit has reduced movement cost on forest, cave, mountain, frozen, and water terrain."
                [/dummy]
            [/abilities] )}
            {EFFECT movement_costs (replace=yes
                [movement_costs]{MARCH_MOVEMENT}[/movement_costs] )}
            {EFFECT defense (replace=yes
                [defense]       {MARCH_DEFENSE}        [/defense] )}
        )}
    [/event]
    #------------------
    # FENCER
    #------------------
    # backstabs on a fencer. Extremely strong
    [event]
        name,first_time_only=unit placed,no
        {FILTER type_adv_tree=Fencer}
        {FILTER_CONDITION( {HAVE_UNIT side,ability=$unit.side,exacting} )}
        
        {REMOVE_OBJECT exacting_object id=$unit.id}
        {GIVE_OBJECT_TO id=$unit.id (id=exacting_object
            {EFFECT attack (range=melee
                [set_specials] mode=append {WEAPON_SPECIAL_BACKSTAB} [/set_specials] )}
        )}
    [/event]
    #------------------
    # BOWMAN
    #------------------
    # marksman is useful, but not nearly as extreme as HI/fencers
    [event]
        name,first_time_only=unit placed,no
        {FILTER type_adv_tree=Bowman}
        {FILTER_CONDITION( {HAVE_UNIT side,ability=$unit.side,exacting} )}
        
        {REMOVE_OBJECT exacting_object id=$unit.id}
        {GIVE_OBJECT_TO id=$unit.id (id=exacting_object
            {EFFECT attack (range=ranged
                [set_specials] mode=append {WEAPON_SPECIAL_MARKSMAN} [/set_specials] )}
        )}
    [/event]
#enddef

#############################
# MOREMIRMU
#############################
#define ABILITY_REJUVENATE
    # just heals+4 and regenerate+4 jammed together into 1 ability name
    # combine them into 1 ability so that his abilites are legible in the UI
    [dummy]
        id,name=rejuvenate,_"rejuvenate"
        description= _ "This unit will heal itself and adjacent allied units for 4 HP each turn. This ability cannot cure poison, however, only delay its effect."
    [/dummy]
    [heals]
        value=4
        id=healing
        affect_allies=yes
        affect_self=no
        poison=slowed
        [affect_adjacent]
        [/affect_adjacent]
    [/heals]
    [regenerate]
        value=4
        id=regenerates
        affect_self=yes
        poison=slowed
    [/regenerate]
#enddef

#define USE_SMITE
    {VARIABLE smite_is_active yes} # prevent units dying via smite from triggering more smites
    {ANIMATE_UNIT id=$second_unit.id smite}
    [lua]
        code=<<
            local attacker = wesnoth.units.find_on_map({ id=wml.variables["second_unit"].id })[1]
            local defenders = wesnoth.units.find_on_map({ 
                wml.tag.filter_adjacent{ id=wml.variables["second_unit"].id },
                wml.tag.filter_side{ wml.tag.enemy_of{ side=wml.variables["second_unit"].side } },
                wml.tag["not"]{ id=wml.variables["unit"].id } -- or else we play $unit.id's death animation twice
            })
            
            -- animate and deal damage
            local animator = wesnoth.units.create_animator()
            for i,defender in ipairs(defenders) do
                local damage = math.floor( 30 * ( 100 - defender:resistance_against("arcane", false, defender.x, defender.y) )/100 )
                defender.facing = wesnoth.map.get_relative_dir(defender.x, defender.y, attacker.x, attacker.y)
                animator:add(  defender, "defend", "hit", { with_bars=true, text=tostring(damage), color={255,0,0} }  )
                defender.hitpoints = defender.hitpoints - damage
            end
            animator:run()
            animator:clear()
            
            -- animate death
            local animator = wesnoth.units.create_animator()
            for i,defender in ipairs(defenders) do if (defender.hitpoints<=0) then
                animator:add(  defender, "death", "hit", {}  )
            end end
            animator:run()
            animator:clear()
            
            -- kill units
            for i,defender in ipairs(defenders) do if (defender.hitpoints<=0) then
                wesnoth.game_events.fire("die", defender.loc, attacker.loc)
                wesnoth.units.erase(defender)
            end end
        >>
    [/lua]
    {CLEAR_VARIABLE smite_is_active}
#enddef
#define ABILITY_SMITE
    # this ability is REALLY strong - but since the final scenario in this campaign involves fighting against humans,
    # who're both lawful and resist arcane (both of which nerf Moremirmu), I think it's an appropriate amount of power
    [dummy]
        id,name=smite,_"smite"
        description= _ "Each time this unit strikes a finishing blow, it deals 30 arcane damage to adjacent enemies."
    [/dummy]
#enddef
#define GLOBAL__SMITE_IMPLEMENTATION
    # can't put the implementation inside [dummy], because events inside an ability only get include in a scenario if a *unit type* with that ability is added to the scenario
    # since we give Moremirmu this ability via an [object], his unit type doesn't have the ability, and thus the event would never get included
    [event]
        name=die
        first_time_only=no
        {FILTER_SECOND ability=smite}
        [filter_condition]
            {HAVE_UNIT( # don't trigger this ability unless we have someone to hit with it
                {FILTER_ADJACENT id=$second_unit.id}
                {FILTER_SIDE([enemy_of]
                    side=$second_unit.side
                [/enemy_of])}
                {NOT id=$unit.id}
            )}
            {VARIABLE_CONDITIONAL smite_is_active not_equals yes}
        [/filter_condition]
        {USE_SMITE}
    [/event]
#enddef

#############################
# ITEMS
#############################
#define OBJECT_BLOODAXE WML
    [object]
        {WML}
        id=bloodaxe
        {EFFECT attack (
            range=melee
            set_description=_"bloodaxe"
            set_icon=attacks/frenzy.png
            increase_damage=2
            [set_specials]
                mode=append
                {WEAPON_SPECIAL_DRAIN}
            [/set_specials]
        )}
    [/object]
#enddef
